{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/LotteryCommon.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n    enum RoundVictoryTier {\n        NO_WIN,\n        Tier5_1,\n        Tier5,\n        Tier4_1,\n        Tier4,\n        Tier3_1,\n        Tier3,\n        Referrer,\n        PublicPool,\n        TokenHolders,\n        Treasury\n    }\n\n    struct Round {\n        uint256 id;\n        uint256 startTime;\n        uint256 endTime;\n        bool ended;\n        uint16[] roundNumbers;\n        uint16 powerNumber;\n        uint16[] referralWinnersNumber;\n        uint16 referralWinnersNumberCount;\n        uint256[] ticketIds;\n        uint16 ticketsCount;\n        uint256[] referralTicketIds;\n        uint16 referralCounts;\n    }\n\n    struct Ticket {\n        uint256 id;\n        address participantAddress;\n        address referralAddress;\n        bool claimed;\n        uint256 chainId;\n        RoundVictoryTier victoryTier;\n        uint16 powerNumber;\n    }\n\n    struct TicketResults {\n        uint256 ticketId;\n        RoundVictoryTier victoryTier;\n    }\n\n    struct ReferralTicket {\n        uint256 id;\n        address referralAddress;\n        uint16 referralTicketNumber;\n        bool winner;\n        bool claimed;\n    }\n\n    struct ReferralTicketResults {\n        uint256 referralTicketId;\n        bool won;\n    }"
    },
    "contracts/LotteryRound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { RoundVictoryTier, Round, Ticket, TicketResults, ReferralTicket, ReferralTicketResults } from \"./LotteryCommon.sol\";\n\ncontract LotteryRound is Ownable {\n    Round public round;\n    function getRound() public view returns (Round memory) {\n        return round;\n    }\n\n    Ticket[] public tickets;\n    function ticketById(uint256 ticketId) public view returns (Ticket memory) {\n        return tickets[ticketId];\n    }\n    mapping(uint256 => uint16[]) public ticketNumbers;\n    function numbersForTicketId(uint256 ticketId) public view returns (uint16[] memory) {\n        return ticketNumbers[ticketId];\n    }\n    mapping(address => uint256[]) public roundTicketsByAddress;\n    mapping(address => uint256) public roundTicketsByAddressCount;\n\n    ReferralTicket[] public referralTickets;\n    function referralTicketById(uint256 index) public view returns (ReferralTicket memory) {\n        return referralTickets[index];\n    }\n    mapping(address => uint256[]) public roundReferralTicketsByAddress;\n    mapping(address => uint256) public roundReferralTicketsByAddressCount;\n\n    mapping(RoundVictoryTier => uint256) public victoryTierAmounts;\n    mapping(RoundVictoryTier => uint256) public victoryTierAmountsClaimed;\n    mapping(RoundVictoryTier => uint256) public winnersForEachTier;\n    address public previousRound;\n\n    uint16[]  public  poolPercentagesBasePoints = [7000, 3500, 1500, 1000, 700, 500, 300, 1500, 1000, 5000];\n    function setPoolPercentagesBasePoints(uint16[] memory _poolPercentagesBasePoints) public onlyOwner {\n        poolPercentagesBasePoints = _poolPercentagesBasePoints;\n    }\n\n    constructor(address previousRoundAddress, uint256 roundDurationInSeconds) Ownable(msg.sender) {\n        uint256 id = 1;\n        previousRound = previousRoundAddress;\n        if (previousRoundAddress != address(0)) {\n            LotteryRound previousLotteryRound = LotteryRound(previousRoundAddress);\n            id = previousLotteryRound.getRound().id + 1;\n            propagateWinningFromPreviousRound();\n        }\n        round = Round({\n            id: id,\n            startTime: block.timestamp,\n            endTime: block.timestamp + roundDurationInSeconds,\n            ended : false,\n            roundNumbers: new uint16[](0),\n            powerNumber: 0,\n            referralWinnersNumber: new uint16[](0),\n            referralWinnersNumberCount : 0,\n            ticketIds : new uint256[](0),\n            ticketsCount : 0,\n            referralTicketIds : new uint256[](0),\n            referralCounts : 0\n        });\n    }\n\n    function propagateWinningFromPreviousRound() internal {\n        LotteryRound previousLotteryRound = LotteryRound(previousRound);\n        victoryTierAmounts[RoundVictoryTier.Tier5_1] += previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier5_1) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier5_1);\n        victoryTierAmounts[RoundVictoryTier.Tier5] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier5) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier5);\n        victoryTierAmounts[RoundVictoryTier.Tier4_1] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier4_1) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier4_1);\n        victoryTierAmounts[RoundVictoryTier.Tier4] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier4) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier4);\n        victoryTierAmounts[RoundVictoryTier.Tier3_1] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier3_1) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier3_1);\n        victoryTierAmounts[RoundVictoryTier.Tier3] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Tier3) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Tier3);\n        victoryTierAmounts[RoundVictoryTier.PublicPool] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.PublicPool) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.PublicPool);\n        victoryTierAmounts[RoundVictoryTier.Referrer] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Referrer) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Referrer);\n        victoryTierAmounts[RoundVictoryTier.TokenHolders] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.TokenHolders) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.TokenHolders);\n        victoryTierAmounts[RoundVictoryTier.Treasury] +=  previousLotteryRound.victoryTierAmounts(RoundVictoryTier.Treasury) - previousLotteryRound.victoryTierAmountsClaimed(RoundVictoryTier.Treasury);\n    }\n\n    function numberIsInRangeForRound(uint256 number) public pure returns (bool) {\n        return number > 0 && number <= 69;\n    }\n\n    function numberIsInRangeForPowerNumber(uint256 number) public pure returns (bool) {\n        return number > 0 && number <= 26;\n    }\n\n    function validateBuyTicket(uint16[] memory numbers, uint16 powerNumber, address referral ) public view onlyOwner {\n        require(tx.origin != address(0), \"Invalid sender\");\n        require(block.timestamp < round.endTime, \"Round is over\");\n        require(numbers.length == 5, \"Invalid numbers count\");\n        for (uint i = 0; i < numbers.length; i++) {\n            require(numberIsInRangeForRound(numbers[i]), \"Invalid numbers\");\n        }\n        require(numberIsInRangeForPowerNumber(powerNumber), \"Invalid power number\");\n        require(referral != tx.origin, \"Referral cannot be the same as the participant\");\n    }\n\n    function percentageInBasisPoint(uint256 amount, uint256 basisPoint) public pure returns (uint256) {\n        return amount * basisPoint / 10000;\n    }\n\n    function treasuryAmountOnTicket(uint256 paymentTokenAmount) public view returns (uint256) {\n        return percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[9]);\n    }\n\n    function updateVictoryPoolForTicket(uint256 paymentTokenAmount) public onlyOwner {\n        uint256 forPublicPool = percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[0]);\n        victoryTierAmounts[RoundVictoryTier.Tier5_1] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[1]);\n        victoryTierAmounts[RoundVictoryTier.Tier5] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[2]);\n        victoryTierAmounts[RoundVictoryTier.Tier4_1] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[3]);\n        victoryTierAmounts[RoundVictoryTier.Tier4] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[4]);\n        victoryTierAmounts[RoundVictoryTier.Tier3_1] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[5]);\n        victoryTierAmounts[RoundVictoryTier.Tier3] += percentageInBasisPoint(forPublicPool, poolPercentagesBasePoints[6]);\n        victoryTierAmounts[RoundVictoryTier.PublicPool] += forPublicPool;\n        victoryTierAmounts[RoundVictoryTier.Referrer] += percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[7]);\n        victoryTierAmounts[RoundVictoryTier.TokenHolders] += percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[8]);\n        victoryTierAmounts[RoundVictoryTier.Treasury] += treasuryAmountOnTicket(paymentTokenAmount);\n    }\n\n    function buyTicket(uint256 chainId, uint16[] memory chosenNumbers, uint16 powerNumber, address referral) public onlyOwner {\n        validateBuyTicket(chosenNumbers, powerNumber, referral);\n\n        uint256 ticketId = tickets.length;\n        tickets.push(Ticket({\n            id: ticketId,\n            participantAddress: tx.origin,\n            referralAddress: referral,\n            claimed: false,\n            chainId: chainId,\n            victoryTier: RoundVictoryTier.NO_WIN,\n            powerNumber: powerNumber\n        }));\n        for(uint i = 0; i < chosenNumbers.length; i++) {\n            ticketNumbers[ticketId].push(chosenNumbers[i]);\n        }\n        round.ticketIds.push(ticketId);\n        round.ticketsCount++;\n\n        roundTicketsByAddress[msg.sender].push(tickets.length - 1);\n        roundTicketsByAddressCount[msg.sender]++;\n        if (referral != address(0)) {\n            uint256 referralTicketId = referralTickets.length;\n            round.referralTicketIds.push(referralTicketId);\n            round.referralCounts++;\n            referralTickets.push(ReferralTicket({\n                id: referralTicketId,\n                referralAddress: referral,\n                referralTicketNumber: uint16(round.referralCounts),\n                winner: false,\n                claimed: false\n            }));\n\n            roundReferralTicketsByAddress[referral].push(referralTickets.length - 1);\n            roundReferralTicketsByAddressCount[referral]++;\n        }\n    }\n\n    function closeRound() public onlyOwner {\n        require(block.timestamp >= round.endTime, \"Round is not over yet\");\n        round.ended = true;\n    }\n\n    function couldReceiveWinningNumbers() public view {\n        require(block.timestamp >= round.endTime, \"Round is not over yet\");\n        require(round.roundNumbers.length == 0, \"Winning numbers already set\");\n    }\n\n    function storeWinningNumbers(uint16[] memory roundNumbers, uint16 powerNumber, uint16[] memory referralWinnersNumber) public onlyOwner {\n        round.roundNumbers = roundNumbers;\n        round.powerNumber = powerNumber;\n        round.referralWinnersNumber = referralWinnersNumber;\n        round.referralWinnersNumberCount = uint16(referralWinnersNumber.length);\n    }\n\n    function markWinners(TicketResults[] memory ticketResults, ReferralTicketResults[] memory referralTicketResults) public onlyOwner {\n        for (uint i = 0; i < ticketResults.length; i++) {\n            TicketResults memory ticketResult = ticketResults[i];\n            Ticket storage ticket = tickets[ticketResult.ticketId];\n            ticket.victoryTier = ticketResult.victoryTier;\n            winnersForEachTier[ticketResult.victoryTier]++;\n        }\n        for (uint i = 0; i < referralTicketResults.length; i++) {\n            ReferralTicketResults memory referralTicketResult = referralTicketResults[i];\n            ReferralTicket storage referralTicket = referralTickets[referralTicketResult.referralTicketId];\n            referralTicket.winner = referralTicketResult.won;\n            if (referralTicketResult.won) {\n                winnersForEachTier[RoundVictoryTier.Referrer]++;\n            }\n        }\n    }\n\n    function markVictoryClaimed(uint256 ticketId, uint256 amountClaimed) public onlyOwner {\n        Ticket storage ticket = tickets[ticketId];\n        ticket.claimed = true;\n        victoryTierAmountsClaimed[ticket.victoryTier] += amountClaimed;\n    }\n\n    function markReferralVictoryClaimed(uint256 referralTicketId, uint256 amountClaimed) public onlyOwner {\n        ReferralTicket storage referralTicket = referralTickets[referralTicketId];\n        referralTicket.claimed = true;\n        victoryTierAmountsClaimed[RoundVictoryTier.Referrer] += amountClaimed;\n    }\n}"
    },
    "contracts/LotteryRoundCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"./LotteryRoundCreatorInterface.sol\";\nimport \"./LotteryRound.sol\";\n\ncontract LotteryRoundCreator is LotteryRoundCreatorInterface, Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    function startNewRound(uint256 roundDurationInSeconds, address previousRoundAddress) public override onlyOwner returns(address) {\n        LotteryRound newRound = new LotteryRound(previousRoundAddress, roundDurationInSeconds);\n        newRound.transferOwnership(owner());\n        return address(newRound);\n    }\n}"
    },
    "contracts/LotteryRoundCreatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ninterface LotteryRoundCreatorInterface {\n   function startNewRound(uint256 roundDurationInSeconds, address previousRoundAddress) external returns(address);\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}