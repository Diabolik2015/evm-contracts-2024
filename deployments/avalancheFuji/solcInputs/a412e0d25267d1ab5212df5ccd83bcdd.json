{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/LotteryCommon.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n    enum RoundVictoryTier {\n        Tier5_1,\n        Tier5,\n        Tier4_1,\n        Tier4,\n        Tier3_1,\n        Tier3,\n        Referrer,\n        TokenHolders,\n        Treasury,\n        NO_WIN\n    }\n\n    struct Round {\n        uint256 id;\n        uint256 uiId;\n        uint256 startTime;\n        uint256 endTime;\n        bool ended;\n        uint16[] roundNumbers;\n        uint256[] referralWinnersNumber;\n        uint16 referralWinnersNumberCount;\n        uint256[] ticketIds;\n        uint16 ticketsCount;\n        uint256[] referralTicketIds;\n        uint16 referralCounts;\n    }\n\n    struct Ticket {\n        uint256 id;\n        address participantAddress;\n        address referralAddress;\n        bool claimed;\n        uint256 chainId;\n        RoundVictoryTier victoryTier;\n    }\n\n    struct TicketResults {\n        uint256 ticketId;\n        address participantAddress;\n        RoundVictoryTier victoryTier;\n        bool won;\n        bool claimed;\n        uint256 amountWon;\n    }\n\n    struct ReferralTicket {\n        uint256 id;\n        address buyerAddress;\n        address referralAddress;\n        uint256 referralTicketNumber;\n        bool winner;\n        bool claimed;\n    }\n\n    struct ReferralTicketResults {\n        uint256 referralTicketId;\n        address buyerAddress;\n        address referralAddress;\n        uint256 referralTicketNumber;\n        bool won;\n        bool claimed;\n        uint256 amountWon;\n    }"
    },
    "contracts/LotteryRound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { RoundVictoryTier, Round, Ticket, TicketResults, ReferralTicket, ReferralTicketResults } from \"./LotteryCommon.sol\";\nimport {LotteryRoundInterface} from \"./LotteryRoundInterface.sol\";\n\ncontract LotteryRound is Ownable, LotteryRoundInterface {\n    Round public round;\n    function getRound() public view returns (Round memory) {\n        return round;\n    }\n\n    Ticket[] public tickets;\n    function ticketById(uint256 ticketId) public view returns (Ticket memory) {\n        return tickets[ticketId];\n    }\n    mapping(uint256 => uint16[]) public ticketNumbers;\n    function numbersForTicketId(uint256 ticketId) public view returns (uint16[] memory) {\n        return ticketNumbers[ticketId];\n    }\n    mapping(address => uint256[]) public roundTicketsByAddress;\n    mapping(address => uint256) public roundTicketsByAddressCount;\n\n    ReferralTicket[] public referralTickets;\n    function referralTicketById(uint256 index) public view returns (ReferralTicket memory) {\n        return referralTickets[index];\n    }\n    mapping(address => uint256[]) public roundReferralTicketsByAddress;\n    mapping(address => uint256) public roundReferralTicketsByAddressCount;\n\n    mapping(RoundVictoryTier => uint256) public victoryTierAmounts;\n    mapping(RoundVictoryTier => uint256) public victoryTierAmountsClaimed;\n    uint256 public totalVictoryPool;\n    uint256 public totalClaimed;\n    mapping(RoundVictoryTier => uint256) public amountWonForEachTicket;\n    address public previousRound;\n\n    uint16[]  public  poolPercentagesBasePoints = [3000, 1500, 1000, 700, 500, 300, 1500, 1000, 500];\n    function setPoolPercentagesBasePoints(uint16[] memory _poolPercentagesBasePoints) public onlyOwner {\n        poolPercentagesBasePoints = _poolPercentagesBasePoints;\n    }\n\n    constructor(address previousRoundAddress, uint256 _statusStartTime, uint256 _statusEndTime, uint256 id, uint256 uiId) Ownable(msg.sender) {\n        previousRound = previousRoundAddress;\n        if (previousRoundAddress != address(0)) {\n            propagateWinningFromPreviousRound();\n        }\n        round = Round({\n            id: id,\n            uiId:  uiId,\n            startTime: _statusStartTime,\n            endTime: _statusEndTime,\n            ended : false,\n            roundNumbers: new uint16[](0),\n            referralWinnersNumber: new uint256[](0),\n            referralWinnersNumberCount : 0,\n            ticketIds : new uint256[](0),\n            ticketsCount : 0,\n            referralTicketIds : new uint256[](0),\n            referralCounts : 0\n        });\n    }\n\n    function propagateWinningFromPreviousRound() internal {\n        LotteryRound previousLotteryRound = LotteryRound(previousRound);\n        updateVictoryPoolForTicket(previousLotteryRound.totalVictoryPool() - previousLotteryRound.totalClaimed());\n    }\n\n    function numberIsInRangeForRound(uint256 number) public pure returns (bool) {\n        return number > 0 && number <= 69;\n    }\n\n    function numberIsInRangeForPowerNumber(uint256 number) public pure returns (bool) {\n        return number > 0 && number <= 26;\n    }\n\n    function validateBuyTicket(uint16[] memory numbers, address referral) public view onlyOwner {\n        require(tx.origin != address(0), \"Invalid sender\");\n        require(block.timestamp < round.endTime, \"Round is over\");\n        require(numbers.length == 6, \"Invalid numbers count\");\n        for (uint i = 0; i < numbers.length - 1; i++) {\n            require(numberIsInRangeForRound(numbers[i]), \"Invalid numbers\");\n        }\n        require(numberIsInRangeForPowerNumber(numbers[5]), \"Invalid power number\");\n        require(referral != tx.origin, \"Referral cannot be the same as the participant\");\n    }\n\n    function percentageInBasisPoint(uint256 amount, uint256 basisPoint) public pure returns (uint256) {\n        return amount * basisPoint / 10000;\n    }\n\n    function treasuryAmountOnTicket(uint256 paymentTokenAmount) public view returns (uint256) {\n        return percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[8]);\n    }\n\n    function updateVictoryPoolForTicket(uint256 paymentTokenAmount) public onlyOwner {\n        totalVictoryPool += paymentTokenAmount - percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[uint(RoundVictoryTier.TokenHolders)]) -\n                        percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[uint(RoundVictoryTier.Treasury)]);\n        for(uint i = 0; i < 9; i++) {\n            victoryTierAmounts[RoundVictoryTier(i)] += percentageInBasisPoint(paymentTokenAmount, poolPercentagesBasePoints[i]);\n        }\n    }\n\n    function buyTicket(uint256 chainId, uint16[] memory chosenNumbers, address referral, address buyer) public onlyOwner {\n        validateBuyTicket(chosenNumbers, referral);\n\n        uint256 ticketId = tickets.length;\n        tickets.push(Ticket({\n            id: ticketId,\n            participantAddress: buyer,\n            referralAddress: referral,\n            claimed: false,\n            chainId: chainId,\n            victoryTier: RoundVictoryTier.NO_WIN\n        }));\n        for(uint i = 0; i < chosenNumbers.length; i++) {\n            ticketNumbers[ticketId].push(chosenNumbers[i]);\n        }\n        round.ticketIds.push(ticketId);\n        round.ticketsCount++;\n\n        roundTicketsByAddress[buyer].push(tickets.length - 1);\n        roundTicketsByAddressCount[buyer]++;\n        if (referral != address(0)) {\n            uint256 referralTicketId = referralTickets.length;\n            round.referralTicketIds.push(referralTicketId);\n            round.referralCounts++;\n            referralTickets.push(ReferralTicket({\n                id: referralTicketId,\n                buyerAddress: buyer,\n                referralAddress: referral,\n                referralTicketNumber: uint16(round.referralCounts),\n                winner: false,\n                claimed: false\n            }));\n\n            roundReferralTicketsByAddress[referral].push(referralTickets.length - 1);\n            roundReferralTicketsByAddressCount[referral]++;\n        }\n    }\n\n    function closeRound() public onlyOwner {\n        require(block.timestamp >= round.endTime, \"Round is not over yet\");\n        round.ended = true;\n    }\n\n    function couldReceiveWinningNumbers() public view {\n        require(block.timestamp >= round.endTime, \"Round is not over yet\");\n        require(round.roundNumbers.length == 0, \"Winning numbers already set\");\n    }\n\n    function storeWinningNumbers(uint16[] memory roundNumbers, uint16[] memory referralWinnersNumber) public onlyOwner {\n        round.roundNumbers = roundNumbers;\n        round.referralWinnersNumber = referralWinnersNumber;\n        round.referralWinnersNumberCount = uint16(referralWinnersNumber.length);\n    }\n\n    function markWinners(TicketResults[] memory ticketResults, ReferralTicketResults[] memory referralTicketResults, uint256[] memory amountWonForEachTicketCrossChain) public onlyOwner {\n        for (uint i = 0; i < ticketResults.length; i++) {\n            TicketResults memory ticketResult = ticketResults[i];\n            Ticket storage ticket = tickets[ticketResult.ticketId];\n            ticket.victoryTier = ticketResult.victoryTier;\n        }\n        for (uint i = 0; i < referralTicketResults.length; i++) {\n            ReferralTicketResults memory referralTicketResult = referralTicketResults[i];\n            ReferralTicket storage referralTicket = referralTickets[referralTicketResult.referralTicketId];\n            referralTicket.winner = referralTicketResult.won;\n        }\n        for (uint i = 0; i < 7; i++) {\n            amountWonForEachTicket[RoundVictoryTier(i)] = amountWonForEachTicketCrossChain[i];\n        }\n    }\n\n    function markVictoryClaimed(TicketResults[] memory ticketResults, ReferralTicketResults[] memory referralTicketResults) public onlyOwner {\n        for(uint i = 0; i < ticketResults.length; i++) {\n            TicketResults memory ticketResult = ticketResults[i];\n            Ticket storage ticket = tickets[ticketResult.ticketId];\n            ticket.claimed = true;\n            victoryTierAmountsClaimed[ticketResult.victoryTier] += ticketResult.amountWon;\n            totalClaimed += ticketResult.amountWon;\n        }\n        for(uint i = 0; i < referralTicketResults.length; i++) {\n            ReferralTicketResults memory referralTicketResult = referralTicketResults[i];\n            ReferralTicket storage referralTicket = referralTickets[referralTicketResult.referralTicketId];\n            referralTicket.claimed = true;\n            victoryTierAmountsClaimed[RoundVictoryTier.Referrer] += referralTicketResult.amountWon;\n            totalClaimed += referralTicketResult.amountWon;\n        }\n    }\n\n    function markReferralVictoryClaimed(uint256 referralTicketId, uint256 amountClaimed) public onlyOwner {\n        ReferralTicket storage referralTicket = referralTickets[referralTicketId];\n        referralTicket.claimed = true;\n        victoryTierAmountsClaimed[RoundVictoryTier.Referrer] += amountClaimed;\n    }\n}"
    },
    "contracts/LotteryRoundCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport \"./LotteryRoundCreatorInterface.sol\";\nimport \"./LotteryRound.sol\";\n\ncontract LotteryRoundCreator is LotteryRoundCreatorInterface, Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    function startNewRound(uint256 _statusStartTime, uint256 _statusEndTime, address previousRoundAddress, uint256 id, uint256 uiId) public override onlyOwner returns(address) {\n        LotteryRound newRound = new LotteryRound(previousRoundAddress, _statusStartTime, _statusEndTime, id, uiId);\n        newRound.transferOwnership(owner());\n        return address(newRound);\n    }\n}"
    },
    "contracts/LotteryRoundCreatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ninterface LotteryRoundCreatorInterface {\n   function startNewRound(uint256 _statusStartTime, uint256 _statusEndTime, address previousRoundAddress, uint256 id, uint256 uiId) external returns(address);\n}"
    },
    "contracts/LotteryRoundInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport { RoundVictoryTier, Round, Ticket, TicketResults, ReferralTicket, ReferralTicketResults } from \"./LotteryCommon.sol\";\n\ninterface LotteryRoundInterface {\n    function getRound() external returns(Round memory);\n    function markWinners(TicketResults[] memory ticketResults, ReferralTicketResults[] memory referralTicketResults, uint256[] memory amountWonForEachTicketCrossChain) external;\n    function markVictoryClaimed(TicketResults[] memory ticketResults, ReferralTicketResults[] memory referralTicketResults) external;\n    function markReferralVictoryClaimed(uint256 referralTicketId, uint256 amountClaimed) external;\n    function treasuryAmountOnTicket(uint256 paymentTokenAmount) external view returns (uint256);\n    function updateVictoryPoolForTicket(uint256 paymentTokenAmount) external;\n    function buyTicket(uint256 chainId, uint16[] memory chosenNumbers, address referral, address buyer) external;\n    function closeRound() external;\n    function couldReceiveWinningNumbers() external view;\n    function storeWinningNumbers(uint16[] memory roundNumbers, uint16[] memory referralWinnersNumber) external;\n    function ticketById(uint256 ticketId) external view returns (Ticket memory);\n    function numbersForTicketId(uint256 ticketId) external view returns (uint16[] memory);\n    function referralTicketById(uint256 index) external view returns (ReferralTicket memory);\n    function setPoolPercentagesBasePoints(uint16[] memory _poolPercentagesBasePoints) external;\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}